## 선택 정렬

- 가장 작은 것을 선택해서 앞으로 보낸다.
- i, j, min(최소 값), index(가장 작은 원소가 존재하는 위치), temp(두 숫자를 바꾸기 위한 변수)라는 변수를 사용
- 제일 작은 숫자와 값을 바꾸기 때문에 앞에서부터 정렬이 된다.

구현

```javascript
function selectSort() {
  let arr = [1, 10, 5, 8, 7, 6, 4, 3, 2, 9];
  let index;
  for (let i = 0; i < 10; i++) {
    // 배열에 있는 어떤 값보다 큰 min 변수 지정
    let min = 9999;
    for (let j = i; j < 10; j++) {
      // 제일 작은 숫자 찾기
      if (min > arr[j]) {
        min = arr[j];
        index = j;
      }
    }
    let temp = arr[index];
    arr[index] = arr[i];
    arr[i] = temp;
    console.log(arr);
  }
  return arr;
}
console.log(selectSort());

// [ 1, 10, 5, 8, 7, 6, 4, 3, 2, 9 ]
// [ 1, 2, 5, 8, 7, 6, 4, 3, 10, 9 ]
// [ 1, 2, 3, 8, 7, 6, 4, 5, 10, 9 ]
// [ 1, 2, 3, 4, 7, 6, 8, 5, 10, 9 ]
// [ 1, 2, 3, 4, 5, 6, 8, 7, 10, 9 ]
// [ 1, 2, 3, 4, 5, 6, 8, 7, 10, 9 ]
// [ 1, 2, 3, 4, 5, 6, 7, 8, 10, 9 ]
// [ 1, 2, 3, 4, 5, 6, 7, 8, 10, 9 ]
// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
```

### 시간 복잡도

- 반복문을 2번이나 돈다.
  -> 뒤에서부터 arr의 원소를 10개 + 9개 + ... + 1 반복
  -> 10 x (10 + 1) / 2 = 55
  -> N x (N + 1) / 2
  -> N이 무한대라고 했을 때 N * N으로 표현
  -> O(N*N) == O(N^2)

## 버블 정렬

- 옆에 있는 값과 비교해서 더 작은 값을 앞으로 보내기
- 효율성이 가장 떨어짐
- 가장 큰 값이 맨 뒤로 가 있게 된다.

```javascript
function bubbleSort() {
  let arr = [1, 10, 5, 8, 7, 6, 4, 3, 2, 9];
  for (let i = 0; i < 10; i++) {
    // 집합의 크기를 하나씩 감소시킴
    for (let j = 0; j < arr.length - i; j++) {
      if (arr[j] > arr[j + 1]) {
        temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
    console.log(arr);
  }
  return arr;
}
console.log(bubbleSort());

// [ 1, 5, 8, 7, 6, 4, 3, 2, 9, 10 ]
// [ 1, 5, 7, 6, 4, 3, 2, 8, 9, 10 ]
// [ 1, 5, 6, 4, 3, 2, 7, 8, 9, 10 ]
// [ 1, 5, 4, 3, 2, 6, 7, 8, 9, 10 ]
// [ 1, 4, 3, 2, 5, 6, 7, 8, 9, 10 ]
// [ 1, 3, 2, 4, 5, 6, 7, 8, 9, 10 ]
// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
```

### 시간 복잡도

- for문을 2번이나 돈다.
  -> 앞에서부터 10 + 9 + ... + 1 반복
  -> 10 x (10 + 1) / 2 = 55
  -> N x (N + 1) / 2
  -> N * N으로 표현
  -> O(N*N) == O(N^2)

## 삽입 정렬

- 각 숫자를 적절한 위치에 삽입
- 앞 숫자들이 정렬되어 있다고 가정

```javascript
function insertSort() {
  let arr = [1, 10, 5, 8, 7, 6, 4, 3, 2, 9];
  for (let i = 0; i < 10; i++) {
    for (let j = i; j > 0; j--) {
      if (arr[j - 1] > arr[j]) {
        // 작으면 j랑 j-1이랑 바꾸기
        temp = arr[j];
        arr[j] = arr[j - 1];
        arr[j - 1] = temp;
      } else {
        continue;
      }
    }
    console.log(arr);
  }
  // 다른 풀이 (훨씬 더 좋은 듯)
  for (let i = 1; i < 10; i++) {
    let j = i;
    while (arr[j - 1] > arr[j]) {
      let temp = arr[j];
      arr[j] = arr[j - 1];
      arr[j - 1] = temp;
      j--; // 빼먹지 말 것
    }
    console.log(arr);
  }
  return arr;
}
console.log(insertSort());
// [ 1, 10, 5, 8, 7, 6, 4, 3, 2, 9 ]
// [ 1, 5, 10, 8, 7, 6, 4, 3, 2, 9 ]
// [ 1, 5, 8, 10, 7, 6, 4, 3, 2, 9 ]
// [ 1, 5, 7, 8, 10, 6, 4, 3, 2, 9 ]
// [ 1, 5, 6, 7, 8, 10, 4, 3, 2, 9 ]
// [ 1, 4, 5, 6, 7, 8, 10, 3, 2, 9 ]
// [ 1, 3, 4, 5, 6, 7, 8, 10, 2, 9 ]
// [ 1, 2, 3, 4, 5, 6, 7, 8, 10, 9 ]
// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
```

### 시간 복잡도

- 반복문을 2번이나 돈다.
  -> 앞에서부터 10 + 9 + ... + 1 반복
  -> 10 x (10 + 1) / 2 = 55
  -> N x (N + 1) / 2
  -> N * N으로 표현
  -> O(N*N) == O(N^2)

  시간복잡도는 선택, 버블, 삽입이 모두 동일하지만 실제로는 삽입정렬이 가장 연산의 수가 적게 일어남 -> 3개 중에서는 가장 뛰어나다고 할 수 있음.
  거의 정렬된 상태라면 삽입 정렬은 필요할 때만 삽입을 진행하기 때문에 어떤 알고리즘보다도 빠르다는 특징을 가지고 있다.
